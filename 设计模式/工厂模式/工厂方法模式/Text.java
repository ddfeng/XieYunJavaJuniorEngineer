package 设计模式.工厂模式.工厂方法模式;

import org.junit.Test;

public class Text {
    /**
     * 介绍：工厂方法模式Factory Method，又称多态性工厂模式。在工厂方法模式中，核心的工厂类不再负责所有产品的创建，
     * 而是将具体创建的工作交给子类去做。该核心类成为了一个抽象工厂角色，仅负责给出具体工厂子类必须实现的接口，
     * 而不接触哪一个产品类应当被实例化这种细节
     *
     * 定义：工厂方法模式是简单工厂模式的延伸，解决了很多简单工厂模式的问题，首先完全实现‘开-闭’原则，实现了扩展。
     * 其次更加复杂的层次结构，可以应用于产品结果复杂的场合
     *
     * 延伸：在简单工厂中，我们根据导演的分配来在工厂中创建车，但是导演的性格突然变化，那么导演的指令将会发生无线变化，
     * 这个时候我们就要改变源代码了，这是多么操蛋
     *
     * 模拟场景：
     * 速度与激情赚了一大笔钱，剧组有钱了，导演说我们没有的道具车直接去4s店取，帐记在我身上
     *
     * 其实也就是一个工厂对应一个场景，因为有钱，所以任性
     *
     * 优点:
     * 子类提供挂钩。基类为工厂方法提供缺省实现，子类可以重新新的实现，也可以继承父类实现，更加灵活
     * 屏蔽产品类。产品类无论如何变换，调用者都不用关心，只需要关心产品的接口，只要接口保持不变，系统上层模块就不会变化
     * 典型的解耦框架，高层模型只需要知道产品的抽象类，其他的实现类都不需要关心，符合迪米特法则，符合依赖倒置原则，符合里氏替换原则
     * 多态性，客户代码可以做到与特定应用无关，适用于实体类
     *
     * 缺点：多了点东西，不过这个缺点也不算缺点
     */
    @Test
    public void test() {
        CarFactory benCarFactory = new BenCarFactory();
        CarProduce carProduce = benCarFactory.craeateCar();
        carProduce.task();
    }
}
